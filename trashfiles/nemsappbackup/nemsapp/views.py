"""
- views functions - controls flow of flask app based on URL
- whenever user navigates to new URL generated by pain.py,
- views looks for the corresponding @app.route to decide which
- function to run, and parses any variables within the URL
- to be passed to the proper helper object (i.e. query or plot generator)
"""

from nemsapp import app
import pandas.io.sql as psql
import pymysql as pysql
from flask import *
import pandas as pd
import QueryGenerator as qg


# TODO: re-write app.routes using new object structure

@app.route("/")
def main_view():
    return Response("Main page placeholder", content_type="text/plain")

# TODO: add more variables/query options to route, or find a better way to include them
# currently, app expects to see all possible variables, which means main.py needs to be
# set up to always include all of them in URL, even if blank.
# would be nicer if view could just know to only pass in the variables that
# are present.


# view func for dispalying basic database table
@app.route("/query/table=<tablename>/batch=<batchnum>/model=<modelname>")
def req_query(tablename, batchnum, modelname):
    # parse variables from URL and pass to QueryGenerator object as attributes
    query = qg.QueryGenerator(tablename, batchnum, modelname)
    # populate dataframe by calling send_query() on qg object
    data = query.send_query()
    # TODO: Figure out best practice for when and where to close database connection.
    # For now, will continue putting it in any time the conneciton is no longer needed
    # for current operation.
    query.close_connection()
    # generate descriptive table title from variables
    tabletitle = ("%s, filter by: batch=%s, model=%s" %(tablename, batchnum, modelname))
    
    # generage html page via table.html template, pass in html export of dataframe
    # and table title as variables
    return render_template('table.html', table=data.to_html(classes='Table'),\
                           title=tabletitle)



"""
#COPY PASTE FROM OLD SERVER BELOW TO MAINTAIN FUNCTIONALITY UNTIL NEW PAGES SET UP
#COMMENT OUT EVERYTHING BELOW WHEN READY TO TEST NEW SITE STRUCTURE


#currently only have one user input partially working (dropbox on /index page)
#all other funcitonality accessed directly in address bar based on @approute
#ex to pull up a table of all cells in batch #271, enter address
# "http://127.0.0.1:5000/celllist/batch=271" (or whatever your default server address:port is)

#basic landing page w/ dropboxe for user batch choice
@app.route("/index")
def index_view():
    data = read_table('NarfBatches')
    batchlist = data['batch'].tolist()
    batchlist = list(set(batchlist))
    return render_template('main.html', batchlist = batchlist)


#basic functions for querying based on batch, model etc

#pull cells with matching batchid
@app.route("/celllist/batch=<batchid>")
def show_batch(batchid):
    data = query_batch(batchid)
    data.set_index(['id'], inplace=True)
    data.index.name=None
    return render_template('table.html', table=data.to_html(classes='Table'))

#pull cells with matching modelname
@app.route("/celllist/modelname=<modelname>")
def show_model(modelname):
    data = query_model(modelname)
    data.set_index(['id'], inplace=True)
    data.index.name=None
    return render_template('table.html', table=data.to_html(classes='Table'))

#pull cells with matching batchid and modelname (in that order)
@app.route("/celllist/batch=<batchid>/modelname=<modelname>")
def show_batch_plus_model(batchid, modelname):
    data = query_model_from_batch(batchid, modelname)
    data.set_index(['id'], inplace=True)
    data.index.name=None
    return render_template('table.html', table=data.to_html(classes='Table'))



#basic table pulls below, no filtering
@app.route("/NarfResults")
def show_narfresults():
    data = read_table('NarfResults')
    data.set_index(['id'], inplace=True)
    data.index.name=None
    return render_template('table.html', table=data.to_html(classes='Table'))

@app.route("/NarfBatches")
def show_narfbatches():
    data = read_table('NarfBatches')
    data.set_index(['id'], inplace=True)
    data.index.name=None
    
    return render_template('table.html',table=data.to_html(classes='Table'))
    
@app.route("/gSingleCell")
def show_gsinglecell():
    data = read_table('gSingleCell')
    
    return render_template('table.html',table=data.to_html(classes='Table'))
"""    
#+Title: JERB Spec V0.1

* What are JERBs? What problems do they solve?

  A JERB (JSON Executable Resource Blob; a.k.a. jerb) is an immutable object that stores code or data in an easily-interchanged (JSON) format. Jerbs are intended to help data scientists manage and share their data and code they use for modeling. They are named "jerbs" as a pun on the word "jobs", because they usually contain a small amount of work you would like to have done, such as fitting a model to some data. 

  Jerbs are in the JSON format so that you may store your jerbs in flat files, a database or in the cloud. The jerb can store source code, experimental data, a prediction from a model, or anything you want really. It's just a wrapper with some useful conventions.

  Jerbs reference one another as "parents". This is similar to a GIT commit tree, in that each jerb is part of an acyclic directed graph. In the same way that each git commit is based on a small modification of the previous commit(s), each jerb is based on a small modification of the output of previous jerbs (its "parents").

  Jerbs are immutable, meaning that they cannot be modified or mutated in place. This is for several reasons:

  1. It prevents problems in which two jerbs have the same name or ID number but different versions of the same source code. By being immutable, it essentially provides safe version control for code and data.
  2. If a jerb cannot change, it may be safely cached anywhere, anytime, automatically.
  3. Immutablity allows for massively parallel operations because multiple processes may use a jerb simultaneously and not need to coordinate their operations.
  4. Immutable objects allows "mistakes" to be recorded as dead branches in a computational tree, without impacting the saving of correct computations. You can still delete your mistakes (as long as nobody else is using them yet).
  5. Immutablity reduces the number of operations that jerb indexing systems need to support.
  6. Immutability naturally provides an audit trail of every computation, because newer computations inherently must be based on older ones.

  It is intended that jerbs be usable by developers using any language, and that you may even wish to have have multiple languages participating in some large computation. Although the server's implementation is written in Python, it is also possible that it would be useful for people to write jerbs in the language of their choice. (Footnote: if you see a design decision that locks you into Python, please let me know.)

  It is also intended that jerbs be used in a variety of execution contexts: locally, on your machine during software development; simultaneously across multiple machines or computers in a clustered environment; in a lambda function in the cloud; or even spread across the internet in very large shared computations.

  Finally, because there are security risks associated with sharing data and code, we should just say:

        "Only run jerbs from people that you completely trust!" 

  While there are cryptographically-signed jerbs, which provide a way of restricting the sharing of data and execution to collaborating users, it does not provide security, merely verification. 


* Introduction to Jerbs
** What is a jerb?
   A jerb is a snapshot of code or data at a point in time.

   A jerb is essentially a packed git repository containing only a single commit. It is perfect for storing a data set in various states of preprocessing, or the code for a mathematical model of that data.

   Unlike a git repository, a jerb contains no commit history -- it is just a snapshot of the present state. In this sense, it is less like git and more like a 'package manager' that lets you recreate the state of the code or data that the original author saw at a certain moment. 

   Finally, our mantra is:

             "Jerbs are immutable and uniquely identifiable"

   It is /not possible/ to edit a jerb once created, although it is trivial to create a new jerb that shares many of the same characteristics. As with real life...

        "You cannot rewrite history, but you may reference it freely."

** Why would I want jerbs?
   Here's a thought experiment: how would 1000 people, none of whom who completely trust each other, ever work in the same git repo on similar but not identical projects? They would constantly step on each others' feet. 

   Jerbs are for people who want...
 
   1. ... to collaborate and share with other programmers without the danger of anyone else ever making a change that will break your code.
   2. ... to share different versions of their data, preprocessed in different ways.
   3. ... to publish one version of their code that will be self-contained and work forever, while still allowing development of later versions of that code.
   4. ... to mix and match code from multiple repositories without having to download the history of every repository.
   5. ... to find and index different 'experiments' of code in a way that helps researchers discover the best way to mathematically model some data set.
   6. ... to transfer small pieces of a repository but not its whole history.
   7. ... to coordinate computational work across a cluster of computers in a way that will allow data to be stored in multiple ways.

** What are the parts of a Jerb?
   A Jerb has just three parts:

   1. JID (Jerb ID Number), which is a git commit hash.
   2. Metadata, which is itself a JSON (and must be a dictionary of sequences)
   3. Pack, which is a base-64 encoded .git pack object file containing the 'payload' of the Jerb.

** Pack
   Internally, the pack is the .pack file of a tiny git repo that holds some code or data. 
  
   A git repo is an advantageous storage format because it expands into a git repository:

   1. 'git add' and 'git commit' are familiar commands to developers
   2. git can group multiple files together in any directory structure
   3. git already hashes files so they may are uniquely identifiable
   4. git compresses files using zlib to reduce disk use
   5. git has built-in tools to help resolve merge conflicts between jerbs

** Jerbs are flat files
   Jerbs are self-contained and can be stored anywhere: on the local file system, on a server, in a centralized jerb repo, or in the cloud. They are just a safe, 'over-the-wire' interchange format.

** Indexable
   Of course, flat files are hard to search through quickly. To accomplish this, it is common to index jerbs by any property found in the "metadata" field of a jerb. The jerb_index (i.e. "tracking") server is in fact designed to help you find specific Jerbs quickly, but it does not actually store them. 

** Composable
   Jerbs are designed to be composed, much as you can merge two git repositories together to share code. It is very common to combine a half-dozen Jerbs together, containing code and data, execute the code, and produce a new Jerb from the result. There are tools to help do this (TODO).

** Shareable
   If you want to share jerbs with other researchers, you have two options:
   1) Send them the jerb directly via file transfer methods
   2) Upload your jerb to the centralized repo, and send them the JID (or URL) for the jerb. 

   Jerbs are private for each user by default; you would have to guess a hash to discover somebody else's data, which is very difficult. Also, attempts to randomly guess hashes are easily detected and throttled.

** Restrictions
   There are no restrictions on Jerbs that you use privately, however Jerbs committed to the public repo have the following restrictions:

   1. They must be <10kB in size. If you want to add large files, you are encouraged to put them somewhere web-accessible, and then download them inside your execution script.

   2. They must have <1kB of metadata. 

   These restrictions are because we don't have the money to store everybody's data yet, and the central git server is a potential bottleneck if not properly managed as a shared resource.

** Metadata
   The jerb "metadata" system lets each user attach their own single (editable, change-tracked) JSON to a jerb repo. Metadata provides a way to annotate the repo to describe what its dependencies are, to tag it with searchable keywords, describe what project it is for, and record other information about the jerb.  
   
   Metadata _must_ be formatted as a JSON. If the data is somehow /not/ a JSON, you will be unable to create any Jerbs using 'jerb jerb' and you will receive an error message asking you to fix the problem. (e.g. use 'git notes edit jerb_metadata' in such a case). The rationale for storing metadata as a JSON is because we want to always be able to serialize the metadata as a JSON, and if we stored it in another form this might not be possible.
   
   Aside: Internally, metadata uses the =git notes= system, so it has many of the same limitations that =git notes= has. Specifically, metadata is not pulled/fetched by default, so its history disappears with the original git repo.

   While the original repo exists, metadata is version controlled like everything else. If you want to look through the history of metadata, run "git log -p notes/metadata jerb_metadata".

** Branches
   Jerbs unfortunately don't quite have branches like git. Jerbs only include a single commit, created at the moment the jerb is created. Therefore, they cannot have a true git history, and the concept of 'branches' is not exactly the same. 

   We can, however, use the concept of a "ref", a reference to a specific commit. 

** What is the default metadata?
   By default, several fields are automatically populated by the =jerb= script:
   
   | user    | which is run using                             |
   | branch  | the git branch                                 |
   | parents | a list of parent commit hashes this pulls from |

   It is highly encouraged to also fill in details for:
   | tags        | a list of search tags to index this jerb indexed    |
   | description | a string describing to humans what this jerb is for |

   You may also add your own metadata as desired. It will all be indexed. You may wish to include:
    - Who prepared this jerb, when, on what PC, with what environment
    - Where to start execution of this jerb, if it is executable
    - Keywords or tags so that you may search for this jerb later
   
** Why do I get a different jerb every time I generate a new one from the same repo?
   Because the commit created when the jerb is generated contains a timestamp.

   Our mantra is "jerbs are immutable and unique." It could be very confusing if two jerbs had the same JIDs but different metadata, so we prevent that from occuring by baking in the timestamp.

** I edited the metadata in the JSON and jerbs.org won't accept my jerb. Why?
   The =metadata= field of the jerb is purely a cache so that people can identify the jerb without actually unpacking it. It should not be edited by hand, because the integrity of a jerb is checked by ensuring that the JSON metadata matches what is actually checked in to the jerbs packed git repository. 

   If you received an error, it probably means you edited the jerb's JSON without actually editing the git repo. Try again by starting with =jerb meta= and then generating a new jerb with =jerb jerb=. 

** How do the gory internal details of jerb metadata work?
   First and foremost, using the commands in this section is not recommended unless something has gone horribly wrong. 

   Really, you should probably look elsewhere first.
   
   Still reading? Ok, fine. For those of you trying to debug something that has gone horribly wrong, let's review how jerbs and git repos interact. Normally, a "git note" is used to store metadata on a git object, which is usually either a 'blob', a 'tree', or a 'commit'. Because a jerb is semantically similar to a commit and also to a repo, a design decision was to make the entire repo have the same metadata, rather than connecting our metadata to specific 'hidden' commits that will be discarded when a jerb is generated. 

   For this reason, internally, the jerb script creates a stupid blob object named "jerb_metadata" with the contents "jerb_metadata" in it, and uses the git notes system to annotate that object with notes. 

   Why do we just use "git notes" at all instead of an alternative solution like a flat "metadata.json" file in the root directory? It is mostly to avoid problems with merging two repositories together with =jerb merge=.  Because git notes are not merged by default, by not using the standard commit strategy, we keep accidental cruft from accumulating in repo, and keep the details of metadata largely invisible from users. 

   =jerb meta= is under the hood identical to:

   #+BEGIN_EXAMPLE
   git notes edit jerb_metadata
   #+END_EXAMPLE

** What happens if I publish two jerbs with the same ref?
   The more recent one is what other people will see. This is 99% of the time what you want to happen. If it is not, don't panic! All of the published commits are still in the jerb.

   1. Tag their data at time of submission or execution
   2. Query for jerbs matching a pattern
   3. add, modify, or delete tags

   Note that ALL versions of metadata are stored; once history is written, it cannot be unwritten. Yes, this implies that queries may return multiple results for the same data, and that it is up to the client/viewer to present this information in a way palatable to the user. 

** If I change the metadata on the Jerb, wouldn't that affect other people's queries as well?
   Yes, which is why that changing metadata requires making a new Jerb.

** What happens to my commit messages when I make a Jerb?
   They are lost, except the very last one. Jerbs squash all the commits together into the last one, because a jerb can only contain a single commit. This is intentional: you still have the freedom to explore changes to your code locally and let git manage your code. When the code works and is in a good state, you may then squash your changes together into a single commit (a jerb) that may be committed to the central repository, shared with others, or archived.

** Isn't this a very wasteful way of storing data compared to git?
   It can be, yes. If you update the metadata, this implies you must create a new Jerb. And, if you are storing all your data in the cloud as flat jerb files, some data will be replicated multiple times. If, however, you use a centralized server from which to generate your jerbs, all existing files can simply be referenced instead of copied by the central git server.

   Regardless, to this is that you should always try to keep your jerbs as small as possible. The smaller they are, the less needs to be duplicated, and the easier it will be for other people to reference and reuse your code.

** How do you detect spoofed metadata or a pack? 
   First, they would have to also change the JID, or break the SHA hash. Both of these are plausible for a talented hacker. But, if you are worried about people spoofing your metadata and inserting their own code, ensure that you use HTTPS always and that you sign your jerbs cryptographically with GPG, and then configure your enviornment to only run jerbs that are signed cryptographically. 


* Walkthrough
** How do I create a new Jerb that holds experimental data?    
   Here is an example:

   #+BEGIN_EXAMPLE
   # Create a repo named anything
   jerb init temprepo
   cd temprepo
   cp /path/to/file1.txt /path/to/file2.txt ./
   git add file1.txt file2.txt
   git commit -m "This commit message will be completely ignored."
 
   # Edit the metadata:
   jerb meta   
   
   # Create the jerb
   jerb jerb >> myjerb.jerb

   # Look at the jerb, confirm that the metadata is as you want.

   # Then, publish the jerb for other people to use (including yourself)
   jerb publish myjerb.jerb
   #+END_EXAMPLE

** How do I base my Jerb off of another one?

   There are two strategies for this: 
   1. jerb clone, which is appropriate when you are mostly just modifying a previous jerb.
   2. jerb merge, which is less appropriate. 

   You can 


** How do I update the metadata of an existing jerb?
   You cannot update the metadata "in place", but you _can_ create a new Jerb with the same data and different metadata. 

   Use the standard tools:
   #+BEGIN_EXAMPLE
   jerb init myjerb
   cd myjerb
   jerb merge ../myjerb.jerb
   jerb meta
   jerb jerb >> ../mynewjerb.jerb
   #+END_EXAMPLE


** How do I update the Jerb metadata if it is immutable?
   You cannot update a Jerb because they represent moments in time, and you can't change the past. If you want a different but similar Jerb, clone it, modify the metadata, and then save the new copy:

   #+BEGIN_EXAMPLE
   jerb ref ivar hello | jerb clone 
   cd hello
   jerb meta
   jerb jerb >> new_hello.jerb
   jerb publish new_hello.jerb
   #+END_EXAMPLE

* Infrequently Asked Questions
** How do I back up the Jerb Store?
   There are three JerbStores:
   1. LocalJerbStore, which stores files in a directory
   2. git clone therepo
   
** Is there a way to cryptographically sign commits?
   Yes, you may use GPG to cryptographically sign git commits as usual. 
   TODO: Test this.

** If I delete my Jerb, will other people lose access to it as well?
   At the moment, Yes. 

   In the future, No; if someone else is using it, then it should not be deleted until they no longer have references to it. (TODO)

** How do I get my code to use the latest version other people's code?
   Make a new jerb. 
  
** How do I use this to preprocess data files?
   TODO. Example.

** How do people discover jerbs? 
   TODO. Example

** How do you handle merge conflicts?
   TODO. Git does it. 
    
** What does the HTTP protocol for Jerbs look like?
   TODO
   |-------------+-----------------------------------------------------------|
   | PUT(jid)    | Upload and INDEX Jerb                                     |
   | HEAD(jid)   | Return a 'preview' jerb? Or how many bytes it is? TODO    |
   | GET(jid)    | Get the full Jerb                                         |
   | DELETE(jid) | Remove and UNINDEX Jerb (TODO: iff there are no children) |
   |-------------+-----------------------------------------------------------|

** How do I find the Jerb I am looking for?
   TODO
   
   TODO: I don't recommend adding a "children" search API that is publically facing, because then finding a single JID is the same as finding the entire computational tree, via the capability to find parents and children of a Jerb.

** How do I know if a Jerb is not yet executed?
   TODO

** How do we know who ran something, when?
   Metadata is purely convention; you may create your own metadata properties about each Jerb as you see fit. However, in the interests of cooperation, I might suggest these properties might be useful for introspection:

   |------------------+-------------------------------------------|
   | exec_host        | The host that executed the data           |
   | exec_ip          | The IP of the host that executed the JERB |
   | exec_time_start  | Execution start time                      |
   | exec_time_finish | Execution                                 |
   | exec_user        | The user who executed the src payload     |
   |------------------+-------------------------------------------|

   But of course, there may be other properties that you come up with, like the AWS execution context, the type of EC2 instance running the Jerb, and so on.

** How does my code and data stay secret?
   If you are using the HTTPS connection, nobody will be able to eavesdrop the URLs that you are visiting, which means that they cannot learn your JIDs. Mining hashes is easily detected on the server side and can result in blocking of clients trying to guess JIDs at random.

** How can I share my code and data?
   Give another person your JIDs and they can find your computations and data.
   (TODO: Can this be restricted to children only? Or parents only?)
   
** How do attach documentation to the Jerb?
   If your documentation is too big for "description", you might add new metadata fields:

   | docs    | Documentation for this JERB, what its intent was. |
   | authors | ...                                               |
   | license | ...                                               |
   | DOI     | ...                                               |
   | Version | ...                                               |

** If all Jerbs are given JIDs, how do I organize my Jerbs?
   Organization is basically a problem of indexing, which is well-solved by most databases. Jerbs don't have any mechanism for doing this beyond adding metadata, but that should be enough when combined with an indexing system. Some ideas to get you started:

   (TODO: Provide link to indexing service API module)

* Jerbs as Executable Jobs

  TODO: This section is a work in progress

** Introduction
   The original name for a jerb was JERB ("JSON Executable Resource Blob"), to express that it is a JSON that contains some executable code/data (i.e. work) that you would like done. The fact that JERB is a pun on "job" was intentional, because the goal is to allow versioned execution of code in multiple environments, and if different results are obtained, to store all of them.

** How do I prepare a commit for execution?
   An executable jerb or "prepared" jerb is just an ordinary jerb with an extra convention: a 'exec_main' field should be to the metadata to indicate which file to start executing. For example,

#+BEGIN_EXAMPLE
   {"exec_main": "myfile.sh", ...}
#+END_EXAMPLE

   Clients who wish to execute the code may then unpack the jerb and immediately know where to start. But as I mentioned, this is purely a convention -- certain clients may wish to execute a fuction rather than a shell script, and so you may use whatever convention is most appropriate for your language.

   TODO: Other conventions: exec_fn, exec_py, exec_lib, etc?
    
   Creating a computation JERB manually basically requires that you merge or rebase several other JERBs' git repos together.

    #+BEGIN_EXAMPLE
    # TODO
    jerb fetch <user> <branch> <tag>
    #+END_EXAMPLE

** How do I execute a prepared computation?   
   In Python, something like this should work:

#+BEGIN_EXAMPLE
   import subprocess
   import jerb
   myjerb = ... #TODO
   subprocess.run([myjerb.metadata['exec_main']])
#+END_EXAMPLE

   Optionally, you may want to send the result of the computation back to jerbs.org.

#+BEGIN_EXAMPLE
   # TODO: pack up jerb and send it back
#+END_EXAMPLE

** How can I time the execution of the jerb?
   This is left up to you. There are many options:
   1. Use the =time= command line utility
   2. Use git to make a commit at the moment execution starts, and another when execution finishes, and then take the difference.
   3. Do it in the language of choice.

   The names of the keys in the jerb metadata under which you store information about execution is left up to you, but the following are suggested as conventions:
   1. TODO
   2. TODO

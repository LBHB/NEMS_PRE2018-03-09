#!/usr/bin/python

import os
import sys
import jerb.shell as sh
import jerb.net as net
from jerb.Jerb import Jerb, valid_SHA1_string, load_jerb_from_file
from jerb.JerbRepo import JerbRepo


def print_usage():
    """ Prints usage information to the user. """
    print("""
Usage: jerb <COMMAND> [<ARGS>...]

where COMMAND can be:

  COMMAND        DESCRIPTION
------------------------------------------------------------------------------
  init           Create a new repository
  clone          Create a new repository based on another one
  meta           Edit the repository metadata
  rebase-parents Re-merge the latest versions of parents (TODO)
  jerb           Pack up and print this jerb repo to stdout
  merge          Combine a jerb's contents into the current jerbrepo
------------------------------------------------------------------------------
  find           Given a query json, find all matching published jerbs
  show           Show human-readable, brief summary of a published jerb
  ref            Find the most recent jerb published with a given ref
  orphans        Find jerbs with no published parents
  parents        List the published parents of this jerb
  children       List the published children of this jerb
------------------------------------------------------------------------------
  publish        Publish a jerb to neuralprediction.org
  fetch          Fetch a jerb from neuralprediction.org""")
    
    print("""Example jerb workflow:

    # 1. Find some Jerbs published in the cloud:
    jerb find '{"user": ["ivar", "jacob"]}' # Everything from ivar or jacob
    jerb ref ivar hello  # Get the latest commit to branch: ivar/hello

    # 2. Download the jerbs you want
    jerb fetch b01736e3d0d53d36387af67bc5cdbef78d1b7381 > hello.jerb
    jerb fetch 90d94d3479e40fd001ab4e4c91e3d5b5c7955d43 > world.jerb
    jerb find '{"user": "ivar", "batch": "301"}' | jerb fetch

    # 3. Merge those jerbs into a repo and start working
    jerb init my_new_repo
    cd my_new_repo
    jerb merge ../hello.jerb ../world.jerb
    
    # 4. A) Hack away in this repo with your editor
    #    B) git add, git commit, repeat

    # 5. Optional: update the repo's metadata to tag it with more information
    jerb meta

    # 6. Pack up the git repo into a new jerbfile
    jerb jerb > newjerb.jerb

    # 7. Optional: Publish your jerb snapshot
    jerb publish newjerb.jerb    
    """)


def _jerbs_or_shas(jids_or_files):
    """ Sanitizes the input: accept only JIDS or files, and
    loads them as jerbs. Returns a list of jerbs."""
    jerbs = []
    # Prepare the jerbs to merge
    for f in jids_or_files:
        if valid_SHA1_string(f):
            jerbs.append(net.fetch_jerb(f))
        elif not os.path.exists(f):
            sh.ragequit('Not a file: ' + f)
        else:
            jerbs.append(load_jerb_from_file(f))
    return jerbs


def handle_command_line():
    """ Reads in the arguments from the command line """

    if len(sys.argv) < 2:
        print_usage()
        exit(-1)

    op = sys.argv[1]

    if op == 'init':
        sh.ensure_not_in_git_dir()
        JerbRepo(sys.argv[2], create=True)
        exit(0)

    elif op == 'help':
        print_usage()
        exit(0)

    elif op == 'meta':
        sh.ensure_in_git_dir()
        jr = JerbRepo('./')
        jr.edit_metadata_interactively()
        exit(0)

    elif op == 'jerb':
        sh.ensure_in_git_dir()
        jr = JerbRepo('./')
        js = jr.as_json()
        print(js)
        exit(0)

    elif op == 'clone':
        sh.ensure_not_in_git_dir()
        if len(sys.argv) < 2 or len(sys.argv) > 3:
            sh.ragequit('Usage: jerb clone <file1.jerb or SHA>')
        elif len(sys.argv) == 2:
            jids_or_files = sys.stdin.read().split()
            if len(jids_or_files)>1:
                raise ValueError("Too many JIDS!")
        else:
            jids_or_files = [sys.argv[2]]
        jerbs = _jerbs_or_shas(jids_or_files)
        j = jerbs[0]
        md = j.meta
        if os.path.exists(md['branch']):
            raise ValueError("Cannot clone; branch already exists in this dir: "+md['branch'])
        jr = JerbRepo(md['branch'], create=True)
        jr.set_metadata(md)
        jr.set_metadata_item('parents', [])
        jr.merge_in_jerb(j)
        exit(0)


    elif op == 'parents':
        if len(sys.argv) < 2 or len(sys.argv) > 3:
            sh.ragequit('Usage: jerb parents [<file1.jerb or SHA>]')
        elif len(sys.argv) == 2:
            sh.ensure_in_git_dir()
            jr = JerbRepo('./')
            md = jr.get_metadata()            
        else:
            j = _jerbs_or_shas([sys.argv[2]])[0]
            md = j.meta
        for p in md['parents']:
            print(p)
        exit(0)

    elif op == 'children':
        if len(sys.argv) != 3:
            sh.ragequit("""Usage: jerb children <file1.jerb or SHA>""")
        jos = sys.argv[2]
        j = _jerbs_or_shas([jos])[0]
        jids = net.find_jerbs('{"parents": "' + j.jid + '"}')
        for j in jids:
            print(j)
        exit(0)

    elif op == 'publish':
        if len(sys.argv) < 3:
            sh.ragequit('Usage: jerb publish <file1.jerb> [<file2.jerb> ...]')
        jerbfiles = []
        for f in sys.argv[2:]:
            if not os.path.exists(f):
                sh.ragequit('Not a file: ' + f)
            jerbfiles.append(f)
        for j in jerbfiles:
            (r1, r2) = net.publish_jerbfile(j)

            if (r1.status_code == 200):
                storecode = "EXISTS  "
            elif (r1.status_code == 201):
                storecode = "ADDED   "
            else:
                storecode = "ERROR   "

            if r2.status_code == 200:
                indexcode = "INDEXED "
            else:
                indexcode = "ERROR   "                    

            print(storecode + indexcode + " " + j)

        exit(0)

    elif op == 'find':
        if len(sys.argv) != 3:
            sh.ragequit("""Usage: jerb find '{"user"="ivar"}'""")
        query = sys.argv[2]
        jids = net.find_jerbs(query)
        for j in jids:
            print(j)
        exit(0)

    elif op == 'orphans':
        if len(sys.argv) != 3:
            sh.ragequit("""Usage: jerb orphans <user>""")
        jids = net.rootjids(user=sys.argv[2])
        for j in jids:
            print(j)
        exit(0)

    elif op == 'rebase-parents':
        ensure_in_git_dir();
        if len(sys.argv) != 2:
            sh.ragequit("""Usage: jerb repbase-parents""")            
        #TODO TODO TODO
        exit(0)

    elif op == 'fetch':
        if len(sys.argv) < 2 or len(sys.argv) > 3:
            sh.ragequit('Usage: jerb fetch <jid>')
        elif len(sys.argv) == 2:
            jids = sys.stdin.read().split()
            if len(jids)>1:
                raise ValueError("Too many JIDS!")
        else:
            jids = sys.argv[2:]
        for jid in jids:
            j = net.fetch_jerb(jid)
            print(j, end='')
        exit(0)

    elif op == 'ref':
        if len(sys.argv) != 4:
            sh.ragequit("Usage: jerb ref <user> <branch>")
        user = sys.argv[2]
        branch = sys.argv[3]
        jid = net.get_ref(user, branch)
        if jid:
            print(jid)
        else:
            sys.stderr.write('Nothing found at '+ user + '/' + branch + '\n')
        exit(0)

    elif op == 'merge':    
        sh.ensure_in_git_dir()
        if len(sys.argv) < 2:
            sh.ragequit('Usage: jerb merge [<file1.jerb or SHA> ...]')
        elif len(sys.argv) == 2:
            got = sys.stdin.read()
            jids_or_files = got.split()
        else:
            jids_or_files = sys.argv[2:]        
        jr = JerbRepo('./')
        jerbs = _jerbs_or_shas(jids_or_files)
        # Now actually do the merge
        for j in jerbs:
            jr.merge_in_jerb(j)

    elif op == 'show':    
        if len(sys.argv) < 2:
            sh.ragequit('Usage: jerb show <JID1> [<JID2> ...]')
        elif len(sys.argv) == 2:
            got = sys.stdin.read()
            jids = got.split()
        else:
            jids = sys.argv[2:]
        for jid in jids:
            md = net.fetch_metadata(jid)
            print("{:20.20s}{:20.20s} {:30.30s} {:20.20s}"
                  .format(md['date'],
                          md['user'] + '/' + md['branch'],
                          md['description'],
                          str(md['tags'])))
    else:
        sh.ragequit("Unknown jerb command: " + op)


handle_command_line()

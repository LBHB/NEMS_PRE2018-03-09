"""
- also acting as __init__.py since couldn't get package setup to work
- may need to revisit re-organizing as package in the future, but continuing
- as app for now

- views functions - controls flow of flask app based on URL
- whenever user navigates to new URL generated by pain.py,
- views looks for the corresponding @app.route to decide which
- function to run, and parses any variables within the URL
- to be passed to the proper helper object (i.e. query or plot generator)
"""

import pandas.io.sql as psql
import pymysql as pysql
from flask import *
import pandas as pd
import QueryGenerator as qg
import DB_Connection as dbcon

app = Flask(__name__)
# TODO: re-write app.routes using new object structure

# create a database connection, then assign it to
# dbc to be passed to other objects as needed
db = dbcon.DB_Connection()
dbc = db.connection

@app.route("/")
def main_view():
    # hard coded as only option for now - not really needed for plots,
    # only needed if want to look at tables in adatabase type fashion
    tablelist = 'NarfResults'
    plottypelist = 'ScatterPlot'
    # TODO: currently queries entire table, then picks out batch ids and model names
    # should figure out a better way to do this
    # i.e. don't query anything until user makes a selection
    # read entire celldb one time to create text file lists?
    # then only have to update when new data added, otherwise
    # can pull lists of batch nums, model names etc from text file instead.
    
    batches = qg.QueryGenerator(dbc,'NarfBatches')
    data = batches.send_query()
    batchlist = data['batch'].tolist()
    batchlist = list(set(batchlist))
    
    models = qg.QueryGenerator(dbc,'NarfResults')
    data = models.send_query()
    modellist = data['modelname'].tolist()
    modellist = list(set(modellist))
    
    return render_template('main.html', tablelist = tablelist,\
                           batchlist = batchlist,\
                           modellist = modellist,\
                           plottypelist = plottypelist,
                           )

# takes form data submitted via select objects at '/'
# and uses it to form url for req_query
@app.route("/handle_query", methods = ['POST'])
def handle_query():
    tablename = request.form['tablename']
    batchnum = request.form['batchnum']
    modelname = request.form['modelname']
    
    return redirect(url_for('req_query', tablename=tablename,\
                            batchnum=batchnum, modelname=modelname))


# TODO: add more variables/query options to route, or find a better way to include them
# currently, app expects to see all possible variables, which means main.py needs to be
# set up to always include all of them in URL, even if blank.
# would be nicer if view could just know to only pass in the variables that
# are present.


# view func for dispalying basic database table
@app.route("/query/tablename=<tablename>/batchnum=<batchnum>/modelname=<modelname>")
def req_query(tablename, batchnum, modelname):
    # parse variables from URL and pass to QueryGenerator object as attributes
    query = qg.QueryGenerator(dbc,tablename, batchnum, modelname)
    # populate dataframe by calling send_query() on qg object
    data = query.send_query()

    tabletitle = ("%s, filter by: batch=%s, model=%s" %(tablename, batchnum, modelname))
    
    # generage html page via table.html template, pass in html export of dataframe
    # and table title as variables
    return render_template('table.html', table=data.to_html(classes='Table'),\
                           title=tabletitle)

# take form data submitted at '/'
# and pass to generate_plot function
@app.route("/handle_plot", methods = ['POST'])
def handle_plot():
    plottype = request.form['plottype']
    return redirect(url_for('make_plot',plottype=plottype))
    
@app.route("/plot/plottype=<plottype>")
def make_plot(plottype):
    return "Super awesome scatter plot! Yay!"


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000, debug='True')

#disconnect from database when app shuts down
@app.teardown_appcontext
def disconnect_from_db():
    db.close_connection()

 
"""
- also acting as __init__.py since couldn't get package setup to work
- may need to revisit re-organizing as package in the future, but continuing
- as app for now

- views functions - controls flow of flask app based on URL
- whenever user navigates to new URL generated by pain.py,
- views looks for the corresponding @app.route to decide which
- function to run, and parses any variables within the URL
- to be passed to the proper helper object (i.e. query or plot generator)
"""

import pandas.io.sql as psql
import pymysql as pysql
from flask import *
import pandas as pd
import QueryGenerator as qg
import PlotGenerator as pg
import DB_Connection as dbcon
import webbrowser

app = Flask(__name__)
# TODO: re-write app.routes using new object structure

# create a database connection, then assign it to
# dbc to be passed to other objects as needed
db = dbcon.DB_Connection()
dbc = db.connection

@app.route("/")
def main_view():
    # hard coded as only option for now - not really needed for plots,
    # only needed if want to look at tables in adatabase type fashion
    tablelist = 'NarfResults'
    plottypelist = 'Scatter'
    measurelist = 'r_test'
    # TODO: currently queries entire table, then picks out batch ids and model names
    # should figure out a better way to do this
    # i.e. don't query anything until user makes a selection
    # read entire celldb one time to create text file lists?
    # then only have to update when new data added, otherwise
    # can pull lists of batch nums, model names etc from text file instead.
    
    batches = qg.QueryGenerator(dbc,'NarfBatches')
    data = batches.send_query()
    batchlist = data['batch'].tolist()
    batchlist = list(set(batchlist))
    
    models = qg.QueryGenerator(dbc,'NarfResults')
    data = models.send_query()
    modellist = data['modelname'].tolist()
    modellist = list(set(modellist))
    
    return render_template('main.html', tablelist = tablelist,\
                           batchlist = batchlist,\
                           modellist = modellist,\
                           plottypelist = plottypelist,
                           measurelist = measurelist,
                           )

# takes form data submitted via select objects at '/'
# and uses it to form url for req_query
@app.route("/handle_query", methods = ['POST'])
def handle_query():
    tablename = request.form['tablename']
    batchnum = request.form['batchnum']
    modelname = request.form['modelname']
    
    return redirect(url_for('req_query', tablename=tablename,\
                            batchnum=batchnum, modelname=modelname))


# TODO: add more variables/query options to route, or find a better way to include them
# currently, app expects to see all possible variables, which means main.py needs to be
# set up to always include all of them in URL, even if blank.
# would be nicer if view could just know to only pass in the variables that
# are present.


# view func for dispalying basic database table
@app.route("/query/tablename=<tablename>/batchnum=<batchnum>/modelname=<modelname>")
def req_query(tablename, batchnum, modelname):
    # parse variables from URL and pass to QueryGenerator object as attributes
    query = qg.QueryGenerator(dbc,tablename, batchnum, modelname)
    # populate dataframe by calling send_query() on qg object
    data = query.send_query()

    tabletitle = ("%s, filter by: batch=%s, model=%s" %(tablename, batchnum, modelname))
    
    # generage html page via table.html template, pass in html export of dataframe
    # and table title as variables
    return render_template('table.html', table=data.to_html(classes='Table'),\
                           title=tabletitle)

# take form data submitted at '/'
# and pass to generate_plot function
@app.route("/handle_plot", methods = ['POST'])
def handle_plot():
    plottype = request.form['plottype']
    tablename = request.form['tablename']
    batchnum = request.form['batchnum']
    # TODO: using these names for now since scatter plot only option,
    # but will want new naming scheme when more options added
    modelnameX = request.form['modelnameX']
    modelnameY = request.form['modelnameY']
    measure = request.form['measure']
    
    return redirect(url_for('make_plot',plottype=plottype, tablename=tablename,\
                            batchnum = batchnum, modelnameX = modelnameX,\
                            modelnameY = modelnameY, measure=measure\
                            ))
    
@app.route("/plot/plottype=<plottype>/tablename=<tablename>/batchnum=<batchnum>\
           /modelnameX=<modelnameX>/modelnameY=<modelnameY>/measure=<measure>")
def make_plot(plottype, tablename, batchnum, modelnameX, modelnameY, measure):
    plot = pg.PlotGenerator(dbc, plottype, tablename, batchnum,\
                            modelnameX, modelnameY, measure)

    return render_template("plot.html", script=plot.plot[0], div=plot.plot[1])

    #return plot.plot                       # - takes user to new page w/ plot
    
    """
    webbrowser.open_new_tab(plot.plot)      # - opens new tab w/ plot (not working)
    return redirect(url_for('main_view'))   # - then returns to main page
    """
    
    """ use this instead of redirect for debugging make_plot.
        will return a page with x and y values printed out (if any are present)
    return render_template('debugplot.html', dataX = plot.dataX,\
                           dataY = plot.dataY)
    """
    
# check for empty plot request
@app.route("/empty")
def empty_plot():
    return "Empty plot, sad face, try again! If you're seeing this, the \
            cell list query returned no results"


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000, debug='True')

#disconnect from database when app shuts down
@app.teardown_appcontext
def disconnect_from_db():
    db.close_connection()

 
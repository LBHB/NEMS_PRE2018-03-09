import numpy as np
import pylab as pl
import matplotlib as mp

waveforms = np.load('microphone_data.npy')
fs = 200000

# Problem 1: One thing I glossed over in the previous exercise was that the
# experiment microphone was being recorded using a gain of 10x. That means that
# we passed the signal from the cheap microphone through an amplifier that
# multipled the values by 100x before this was recorded by our hardware. In
# contrast, the signal from the expensive microphone was not amplified. Let's
# correct for the amplification (by dividing the signal from the cheap
# microhpone by a factor of 10x).

## PROBLEM 1 ANSWER
waveforms[:, 0] = waveforms[:, 0]/10.0

# Problem 2: Next, let's look at the frequency response of each microphone.
# Since the point of this exercise isn't to figure out how to compute the FFT, I
# have provided a function, `get_fft`, that performs the calculations for you.
# If you are familiar with the FFT and how to calculate the power spectral
# density and frequency values, you can do it yourself. The function below uses
# the Numpy-style documentation string. This type of documentation string is
# something that most Python programmers in science have accepted as the
# "standard" format for documenting how a function works. The majority of Python
# libraries written for science will use this format.
def get_fft(fs, waveforms):
    '''
    Calculate the frequency response for the provided waveforms

    Parameters
    ----------
    fs : float
        Sampling frequency (in Hz)
    waveforms : n-dimensional array
        Set of waveforms where the last axis (i.e., dimension) is time.

    Returns
    -------
    frequencies : 1D array
        Array of frequencies
    psd : n-dimensional array
        Normalized power spectral density (i.e., the frequency response in units
        of V per Hz). All but the final dimension map to the original dimensions
        of the `waveforms` array. The final dimension is frequency.  For
        example, if `waveforms` is a 3D array with the dimensions corresponding
        to repetition, microphone, time, then `psd` will be a 3D array with
        dimensions corresponding to repetition, microphone, frequency.

    Example
    -------
    To plot the frequency response of the microphone (remember that waveforms is
    a 3D array with repetition, microphone and time as the dimensions):
    >>> waveforms = np.load('microphone_data.npy')
    >>> fs = 200000
    >>> frequencies, psd = get_fft(fs, waveforms)
    >>> mean_psd = np.mean(psd, axis=0)
    >>> pl.loglog(frequencies, psd[0], 'k-')    # cheap microphone
    >>> pl.loglog(frequencies, psd[1], 'r-')    # expensive microphone
    >>> pl.xlabel('Frequency (Hz)')
    >>> pl.ylabel('Power (Volts)')
    '''
    n_time = waveforms.shape[-1]
    frequencies = np.fft.rfftfreq(n_time, fs**-1)
    csd = np.fft.rfft(waveforms)/n_time
    psd = 2*np.abs(csd)/np.sqrt(2.0)
    return frequencies, psd

# Figure out how to use this function to help you calculate the average
# frequency response (i.e., power spectral density or psd) of each microphone
# and plot it (on the same plot). Both the X and Y axes should be set to
# logarithmic scale. Is it better to average across repetitions before or after
# computing the FFT?

## PROBLEM 2 ANSWER

pl.figure()

frequencies, psd = get_fft(fs, waveforms)
mean_psd_after = np.mean(psd, axis=0)
ax1 = pl.subplot(1, 2, 1)
ax1.loglog(frequencies, mean_psd_after[0], label='Cheap')
ax1.loglog(frequencies, mean_psd_after[1], label='Expensive')
ax1.set_xlabel('Frequency (Hz)')
ax1.set_ylabel('Power (Volts)')
ax1.legend()

mean_waveforms = np.mean(waveforms, axis=0)
frequencies, mean_psd_before = get_fft(fs, mean_waveforms)
ax2 = pl.subplot(1, 2, 2, sharex=ax1, sharey=ax1)
ax2.loglog(frequencies, mean_psd_before[0], label='Cheap')
ax2.loglog(frequencies, mean_psd_before[1], label='Expensive')
ax2.set_xlabel('Frequency (Hz)')
ax2.set_ylabel('Power (Volts)')

# Averaging before computing the FFT results in a better signal at high
# frequencies. Let's work with the PSD computed using this approach for all
# subsequent problems.

mean_psd = mean_psd_before

# Problem 3: When the microphones detect changes in air pressure generated by
# sound waves (measured in units of Pascals), they generate a tiny electrical
# signal (measured in units of Volts). The microphone's sensitivity is measured
# as the voltage generated by a single Pascal. More sensitive microphones
# generate a larger voltage. The expensive microphone has a nominal sensitivity
# of 0.92 mV/Pa. The cheap microphone has a nominal sensitivity of 22.4 mV/Pa.
# The frequency response you calculated above is in volts. Convert this value to
# Pascals. Try to use Numpy's broadcasting feature if possible.

## PROBLEM 3 ANSWER

millivolts_per_pascal = np.array([22.4, 0.92])
volts_per_pascal = millivolts_per_pascal/1000.0
pascal_psd = mean_psd/volts_per_pascal[..., np.newaxis]

# Problem 4: Once you have converted the frequency response from volts to
# Pascals, convert it to units of dB SPL. The formula for dB SPL is:
#
#   db_spl = 20*log10(pascals/20e-6)
#
# Create a plot that compares the frequency response (in dB SPL) of the
# expensive microphone with the cheap microphone. Since the dB scale is
# logarithmic, only the X-axis should be set to a logarithmic scale.

## PROBLEM 4 ANSWER

db_psd = 20*np.log10(pascal_psd/20e-6)

pl.figure()
pl.semilogx(frequencies, db_psd[0], label='Cheap')
pl.semilogx(frequencies, db_psd[1], label='Expensive')
pl.xlabel('Frequency (Hz)')
pl.ylabel('Power (dB SPL)')
pl.legend()

# Problem 5: Ok, I'm starting to get a bit annoyed by the engineering notation
# (e.g., 10^0, 10^1, etc.) used on the X-axis. I'm not an engineer by training,
# so I'd like to chang the default tick label formatting to 1, 10, 100, etc. Use
# Google to help you find some examples on how to do this. Google will be how
# you figure out how to adjust all those fine details of your plots before
# publication.

## PROBLEM 5 ANSWER

ax = pl.gca()
ax.xaxis.set_major_formatter(mp.ticker.ScalarFormatter())

# Problem 6: Note that the responses of the microphones are very close to each
# other each other somewhere between 1000 and 2000 Hz. What is the frequency at
# which they are closest and what is the difference in response, in dB, at this
# frequency?

## PROBLEM 6 ANSWER

mask = (frequencies >= 1000) & (frequencies < 10000)

db_psd_subset = db_psd[:, mask]
frequencies_subset = frequencies[mask]
difference = db_psd_subset[1]-db_psd_subset[0]

i = np.abs(difference).argmin()
frequency = frequencies_subset[i]
delta = difference[i]
print 'Smallest difference is {:0.2f} dB at {:0.0f} Hz'.format(delta, frequency)

# Problem 7: Ignoring measurement error, shouldn't both microphones have
# near-identical results? They are measuring the same signal, so they should be
# reporting the same values. Typically, one would expect this to be the case.
# However, two key details I have glossed over include:
#
#   1. The cheap microphone is located at the end of an oddly-shaped acoustic
#      enclosure. This acoustic enclosure is designed to allow us to position
#      the cheap microphone as close to the ear of an animal as possible. Ears
#      have a very cool phenomenon where they can generate sounds (known as
#      spontaneous emissions). We use this microphone to record these emissions.
#      However, this oddly-shaped cavity filters the sound such that most
#      frequencies are attenuated. By the time the sound arrives at the
#      diaphragm of the cheap microphone, it has been transformed and no longer
#      represents the true acoustic signal that would be delivered to the
#      animal's ear. In contrast, the expensive microphone is positioned where
#      the animal's ear would normally be.  Therefore, the result from the
#      expensive microphone gives us the true output of the speaker.
#
#   2. The sensitivity (i.e., mV/Pa) of the cheap microphone is guaranteed to be
#      accurate from 100 Hz to 10 kHz. Beyond that, the behavior of the
#      microphone is unknown. The expensive microphone is guaranteed to be
#      accurate from 4 Hz to 70 kHz.
#
# Because of point 1 (the cavity the cheap microphone is positioned in
# attenuates various frequencies) and point 2 (the cheap microphone's response
# is not defined for frequencies less than 100 Hz and greater than 10 kHz), we
# need to compute the sensitivity (in mV/Pa) of the cheap microphone.  Here, we
# assume that the expensive microphone is accurate and does not vary as a
# function of frequency.
#
# Remember that in problem 2 you computed the frequency response of the
# microphones, in volts. In problem 3, you assumed that the nominal sensitivity
# of the microphones reported by the manufacturers were accurate across all
# freuqencies. You used this nominal sensitivity to compute the frequency
# response, in pascals, of both microphones. In a perfect world, we could have
# used either microphone to compute the actual output of the speaker.  However,
# as discussed in the problem description, we can't use the nominal sensitivity
# of the cheap microphone to determine the output of the speaker since the
# sensitivity of the microphone varies as a function of frequency.
#
# For the purpose of this problem, we assume that the expensive microphone is
# perfect and that the frequency response, in pascals, for the expensive
# microphone is the true output of the speaker. This gives us the two elements
# we need. The frequency response of the cheap microphone in volts annd the
# output of the speaker in pascals. Compute and plot the sensitivity of the
# cheap microphone as a function of frequency.  Use logarithmic scale for both
# the X and Y axes.

## PROBLEM 7 ANSWER
speaker_pascals = pascal_psd[1]
cheap_volts = mean_psd[0]

sensitivity = (cheap_volts*1000)/speaker_pascals
pl.figure()
pl.loglog(frequencies, sensitivity, 'k-', label='actual sens. of cheap mic.')
pl.xlabel('Frequency (Hz)')
pl.ylabel('Sensitivity of cheap microphone (mV/Pa)')
pl.legend(loc='upper left')

ax = pl.gca()
ax.xaxis.set_major_formatter(mp.ticker.ScalarFormatter())
ax.yaxis.set_major_formatter(mp.ticker.ScalarFormatter())
pl.show()
